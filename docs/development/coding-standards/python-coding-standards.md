# Python Coding Standards

> Version: 1.2.0
>
> Purpose: Define required practices for Python code generation and refactoring
>
> Last Updated: 2025-11-07

## Scope

These standards apply to all Python code within this repository, whether written by humans or generated by AI. They supplement existing project conventions and override ad-hoc preferences when conflicts arise.

## Table of Contents

- [General Expectations](#general-expectations)
  - [Deterministic Behavior](#deterministic-behavior)
  - [Idempotent Operations](#idempotent-operations)
  - [Secret Management](#secret-management)
  - [Version Pinning](#version-pinning)
- [Style and Structure](#style-and-structure)
  - [PEP 8 Compliance](#pep-8-compliance)
  - [Import Organization](#import-organization)
  - [Function Size](#function-size)
  - [String Formatting](#string-formatting)
  - [Future Annotations](#future-annotations)
- [Naming Conventions](#naming-conventions)
  - [snake_case](#snake_case)
  - [PascalCase](#pascalcase-capitalizedwords)
  - [UPPER_SNAKE_CASE](#upper_snake_case)
  - [Complete Example](#complete-example)
- [Typing and Interfaces](#typing-and-interfaces)
  - [Type Hints](#type-hints)
  - [Protocol (Interface Definition)](#protocol-interface-definition)
  - [TypedDict](#typeddict)
  - [Enabling Strict Mode](#enabling-strict-mode)
- [Error Handling and Logging](#error-handling-and-logging)
  - [Exception Hierarchy](#exception-hierarchy)
  - [Custom Exceptions](#custom-exceptions)
  - [Logging Best Practices](#logging-best-practices)
  - [Redacting Secrets](#redacting-secrets)
- [Concurrency and I/O](#concurrency-and-io)
  - [Async/Await for I/O Operations](#asyncawait-for-io-operations)
  - [Context Managers](#context-managers)
  - [Pathlib for File Operations](#pathlib-for-file-operations)
- [Performance Best Practices](#performance-best-practices)
  - [List Comprehensions vs Loops](#list-comprehensions-vs-loops)
  - [Generator Expressions](#generator-expressions)
  - [String Concatenation](#string-concatenation)
  - [Dictionary and Set Operations](#dictionary-and-set-operations)
  - [Avoid Global Lookups in Loops](#avoid-global-lookups-in-loops)
  - [Use Built-in Functions](#use-built-in-functions)
  - [Slots for Memory Optimization](#slots-for-memory-optimization)
  - [Profiling](#profiling)
  - [Lazy Evaluation](#lazy-evaluation)
  - [Avoid Premature Optimization](#avoid-premature-optimization)
- [Testing and Tooling](#testing-and-tooling)
  - [Pytest Basics](#pytest-basics)
  - [Fixtures for Reusable Setup](#fixtures-for-reusable-setup)
  - [Mocking External Dependencies](#mocking-external-dependencies)
  - [Test Markers](#test-markers)
  - [Coverage Measurement](#coverage-measurement)
- [Security and Compliance](#security-and-compliance)
  - [Input Validation with Pydantic](#input-validation-with-pydantic)
  - [Safe Subprocess Execution](#safe-subprocess-execution)
  - [Dependency Scanning](#dependency-scanning)
- [Documentation and Discoverability](#documentation-and-discoverability)
  - [Module-Level Docstrings](#module-level-docstrings)
  - [Function Docstrings](#function-docstrings)
  - [Class Docstrings](#class-docstrings)

## General Expectations

### Deterministic Behavior

**What it means:** Code should produce the same output given the same input, without unexpected side effects.

**Why it matters:** Makes code predictable, testable, and easier to debug.

**Example:**

```python
# Good: Deterministic - always returns same result for same input
def calculate_total(price: float, tax_rate: float) -> float:
    return price * (1 + tax_rate)

# Bad: Non-deterministic - result depends on external state
total = 0
def add_to_total(amount: float) -> float:
    global total
    total += amount
    return total
```

### Idempotent Operations

**What it means:** An operation that can be applied multiple times without changing the result beyond the initial application.

**Why it matters:** Makes systems more resilient and easier to retry safely.

**Example:**

```python
from pathlib import Path

# Good: Idempotent - can run multiple times safely
def ensure_directory_exists(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)

# Bad: Not idempotent - fails on second run
def create_directory(path: Path) -> None:
    path.mkdir()  # Raises error if already exists
```

### Secret Management

- **Never** hard-code passwords, API keys, tokens, or credentials in source code
- Use environment variables: `os.getenv("API_KEY")`
- Use HashiCorp Vault for secret management
- Scrub logs of sensitive data before writing

### Version Pinning

**Why:** Ensures reproducible builds and prevents unexpected breakage from dependency updates.

**How:** Specify exact versions in `requirements.txt` or use lock files:

```txt
# requirements.txt
requests==2.31.0
pydantic==2.5.0
```

## Style and Structure

### PEP 8 Compliance

**What it is:** PEP 8 is the official Python style guide that defines conventions for writing readable code.

**Key rules:**

- Use 4 spaces for indentation (never tabs)
- Maximum line length: choose and enforce one of the following consistently across the repo:
  - 79 characters (PEP 8 traditional, 72 for doc text)
  - 88 characters (Black formatter convention)
- Two blank lines between top-level functions and classes
- One blank line between methods inside a class

**Tools:**

- `black`: Automatic code formatter
- `ruff`: Fast linter that checks and fixes PEP 8 violations

### Import Organization

**Structure:** Organize imports into three groups, separated by blank lines:

1. **Standard library imports** (built into Python)
2. **Third-party imports** (installed via pip)
3. **Local application imports** (your own modules)

**Example:**

```python
# Standard library
import os
import sys
from pathlib import Path
from typing import Optional

# Third-party
import requests
from pydantic import BaseModel

# Local
from myapp.database import Database
from myapp.utils import format_date
```

**Avoid wildcard imports:**

```python
# Bad: Unclear what's being imported
from mymodule import *

# Good: Explicit imports
from mymodule import function_a, function_b
```

### Function Size

**Guideline:** Keep functions to 50 logical lines or fewer.

**Why:** Smaller functions are easier to understand, test, and maintain.

**How to refactor:**

```python
# Bad: Too long and complex
def process_user_data(user_data):
    # 100+ lines of validation, transformation, database operations...
    pass

# Good: Split into focused functions
def validate_user_data(user_data: dict) -> dict:
    """Validate and clean user input."""
    # 10-15 lines of validation
    return cleaned_data

def transform_user_data(data: dict) -> UserModel:
    """Transform dict to domain model."""
    # 10-15 lines of transformation
    return user_model

def save_user(user: UserModel) -> None:
    """Persist user to database."""
    # 10-15 lines of database operations
    pass

def process_user_data(user_data: dict) -> None:
    """Main orchestration function."""
    validated = validate_user_data(user_data)
    user = transform_user_data(validated)
    save_user(user)
```

### String Formatting

**Prefer f-strings** for readability and performance:

```python
name = "Alice"
age = 30

# Good: f-strings (Python 3.6+)
message = f"Hello, {name}! You are {age} years old."

# Acceptable: str.format() for complex cases
message = "User {user[name]} has {user[age]} years".format(user=user_dict)

# Avoid: Old-style % formatting
message = "Hello, %s! You are %d years old." % (name, age)
```

### Future Annotations

**What it does:** Enables postponed evaluation of type hints, allowing forward references and reducing import overhead.

**When to use:** All new modules targeting Python 3.8+

```python
from __future__ import annotations

# Now you can reference classes before they're defined
class Node:
    def __init__(self, value: int, parent: Node | None = None):
        self.value = value
        self.parent = parent
```

## Naming Conventions

Python uses different naming styles for different types of identifiers:

### snake_case

**What it is:** All lowercase with words separated by underscores.

**Used for:** Modules, functions, variables, and method names.

**Examples:**

```python
# Module names
import user_authentication
import database_connection

# Function names
def calculate_total_price():
    pass

def send_email_notification():
    pass

# Variable names
user_name = "Alice"
total_count = 42
is_active = True
```

### PascalCase (CapitalizedWords)

**What it is:** Each word starts with a capital letter, no separators.

**Used for:** Class names.

**Examples:**

```python
class UserAccount:
    pass

class DatabaseConnection:
    pass

class HttpRequest:
    pass
```

### UPPER_SNAKE_CASE

**What it is:** All uppercase with words separated by underscores.

**Used for:** Constants (values that should never change).

**Examples:**

```python
MAX_CONNECTIONS = 100
DEFAULT_TIMEOUT = 30
API_BASE_URL = "https://api.example.com"
PI = 3.14159
```

### Complete Example

```python
# Module: user_manager.py

# Constants
MAX_LOGIN_ATTEMPTS = 3
SESSION_TIMEOUT_SECONDS = 3600

# Class
class UserManager:
    def __init__(self, database_url: str):
        self.database_url = database_url
        self._connection = None

    # Method
    def authenticate_user(self, username: str, password: str) -> bool:
        # Local variables
        is_valid = False
        attempt_count = 0

        # Function logic...
        return is_valid
```

## Typing and Interfaces

### Type Hints

**What they are:** Annotations that specify what types of values functions accept and return.

**Why use them:**

- Catch bugs before runtime with tools like `mypy`
- Improve code documentation
- Enable better IDE autocomplete and refactoring

**Basic examples:**

```python
# Function with type hints
def greet(name: str, age: int) -> str:
    return f"Hello, {name}! You are {age} years old."

# Variables with type hints
user_count: int = 0
is_active: bool = True
username: str = "alice"

# Optional values (can be None)
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    if user_id == 1:
        return "Alice"
    return None  # Returns None if not found
```

**Complex types:**

```python
# Prefer built-in generics on Python 3.9+

# List of strings
names: list[str] = ["Alice", "Bob", "Charlie"]

# Dictionary mapping strings to integers
scores: dict[str, int] = {"Alice": 95, "Bob": 87}

# Tuple with specific types
coordinates: tuple[float, float] = (10.5, 20.3)

# Set of strings
tags: set[str] = {"prod", "blue"}

# Union type (can be one of several types) — Python 3.10+
def process_id(id_value: int | str) -> None:
    pass
```

### Protocol (Interface Definition)

**What it is:** Defines a contract that classes can implement without explicit inheritance (structural subtyping).

**When to use:** When you want to specify behavior without requiring inheritance.

```python
from typing import Protocol

# Define what behavior is required
class Drawable(Protocol):
    def draw(self) -> None:
        """Draw the object."""
        ...

# Any class with a draw() method satisfies this protocol
class Circle:
    def draw(self) -> None:
        print("Drawing circle")

class Square:
    def draw(self) -> None:
        print("Drawing square")

# Function accepts anything that implements Drawable
def render(shape: Drawable) -> None:
    shape.draw()

# Both work without explicit inheritance
render(Circle())
render(Square())
```

### TypedDict

**What it is:** Specifies the structure of dictionaries with specific keys and value types.

**When to use:** When working with structured dictionaries (common with JSON data).

```python
from typing import TypedDict

class UserDict(TypedDict):
    id: int
    name: str
    email: str
    is_active: bool

# Type checker ensures correct structure
def create_user(user_data: UserDict) -> None:
    print(f"Creating user: {user_data['name']}")

# Correct usage
user: UserDict = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "is_active": True
}
create_user(user)
```

### Dataclasses

```python
from dataclasses import dataclass

# slots reduces memory and speeds up attribute access; kw_only clarifies APIs
@dataclass(slots=True, kw_only=True)
class Point:
    x: float
    y: float

    def distance_from_origin(self) -> float:
        return (self.x**2 + self.y**2) ** 0.5

p = Point(x=3.0, y=4.0)
assert p.distance_from_origin() == 5.0
```

### Modern Typing Features

```python
from typing import Literal, Self, Never
from collections.abc import Iterable, Mapping, Callable

def set_mode(mode: Literal["fast", "safe"]) -> None:
    ...

class Builder:
    def add(self, item: str) -> Self:  # fluent API
        return self

def fail(msg: str) -> Never:  # function that never returns
    raise RuntimeError(msg)

def process(items: Iterable[str], transform: Callable[[str], str]) -> list[str]:
    return [transform(i) for i in items]
```

### Enabling Strict Mode

**In pyproject.toml:**

```toml
[tool.mypy]
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

## Error Handling and Logging

### Exception Hierarchy

**Use specific exceptions** to make error handling precise:

```python
# Bad: Too broad
try:
    result = int(user_input)
except:  # Catches everything, including KeyboardInterrupt!
    print("Error")

# Bad: Still too broad
try:
    result = int(user_input)
except Exception:  # Catches almost everything
    print("Error")

# Good: Specific exception
try:
    result = int(user_input)
except ValueError as e:
    print(f"Invalid number format: {e}")
except TypeError as e:
    print(f"Wrong type provided: {e}")
```

### Custom Exceptions

**Create domain-specific exceptions** for better error handling:

```python
# Define custom exceptions
class DatabaseError(Exception):
    """Base exception for database operations."""
    pass

class ConnectionError(DatabaseError):
    """Failed to connect to database."""
    pass

class QueryError(DatabaseError):
    """Failed to execute query."""
    pass

# Use in your code
def execute_query(sql: str) -> list:
    try:
        # Database operation
        pass
    except ConnectionError:
        # Handle connection issues
        raise ConnectionError("Cannot connect to database server")
    except Exception as e:
        # Translate generic errors to domain errors
        raise QueryError(f"Query failed: {sql}") from e
```

### Logging Best Practices

**Use the logging module** instead of print statements:

```python
import logging

# Configure logging (usually done once at application startup)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

def process_payment(amount: float, user_id: int) -> bool:
    logger.info(f"Processing payment of ${amount} for user {user_id}")

    try:
        # Payment logic
        logger.debug(f"Validating payment amount: {amount}")

        if amount <= 0:
            logger.warning(f"Invalid payment amount: {amount}")
            return False

        # Process payment
        logger.info(f"Payment successful for user {user_id}")
        return True

    except Exception as e:
        logger.error(f"Payment failed for user {user_id}: {e}", exc_info=True)
        raise
```

**Log levels:**

- `DEBUG`: Detailed diagnostic information
- `INFO`: General informational messages
- `WARNING`: Something unexpected but not an error
- `ERROR`: An error occurred but application continues
- `CRITICAL`: Serious error, application may not continue

### Structured Logging

```python
import json
import logging

class JsonFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:
        payload = {
            "time": self.formatTime(record, "%Y-%m-%dT%H:%M:%S%z"),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        # include extra fields if present
        payload.update({k: v for k, v in vars(record).items() if k not in vars(logging.makeLogRecord({}))})
        return json.dumps(payload, separators=(",", ":"))

handler = logging.StreamHandler()
handler.setFormatter(JsonFormatter())
logger = logging.getLogger("app")
logger.setLevel(logging.INFO)
logger.addHandler(handler)

logger.info("user login", extra={"user_id": 123})
```
### Redacting Secrets

**Never log sensitive information:**

```python
import re
import logging

def redact_sensitive_data(message: str) -> str:
    """Remove sensitive data from log messages."""
    # Redact credit card numbers
    message = re.sub(r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b', '****-****-****-****', message)
    # Redact email addresses
    message = re.sub(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', '***@***.***', message)
    return message

# Good: Redact before logging
logger.info(redact_sensitive_data(f"User {user_email} made payment with card {card_number}"))
```

## Concurrency and I/O

### Async/Await for I/O Operations

**What it is:** Asynchronous programming allows handling multiple I/O operations concurrently without blocking.

**When to use:** Network requests, file I/O, database queries, any operation that waits for external resources.

**Basic example:**

```python
import asyncio
import aiohttp

# Synchronous version - slow
def fetch_url(url: str) -> str:
    response = requests.get(url)
    return response.text

# Takes 3 seconds for 3 URLs (sequential)
for url in urls:
    content = fetch_url(url)

# Asynchronous version - fast
async def fetch_url_async(url: str) -> str:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

# Takes ~1 second for 3 URLs (concurrent)
async def fetch_all(urls: list[str]) -> list[str]:
    tasks = [fetch_url_async(url) for url in urls]
    return await asyncio.gather(*tasks)

# Run async code
results = asyncio.run(fetch_all(urls))
```

#### Cancellation and timeouts

```python
import asyncio
import aiohttp

async def fetch_with_timeout(url: str) -> str:
    timeout = aiohttp.ClientTimeout(total=5)
    async with aiohttp.ClientSession(timeout=timeout) as session:
        try:
            async with asyncio.timeout(5):  # Python 3.11+
                async with session.get(url) as resp:
                    resp.raise_for_status()
                    return await resp.text()
        except* asyncio.CancelledError:  # propagate cancellations
            raise
        except Exception as e:
            # handle/log error, maybe retry with backoff
            raise
```

### Context Managers

**What they are:** Objects that manage resources and ensure cleanup happens automatically.

**Why use them:** Prevent resource leaks (open files, database connections, locks).

**Built-in examples:**

```python
# File handling - automatically closes file
with open("data.txt", "r") as file:
    content = file.read()
# File is automatically closed here, even if an error occurred

# Database connection - automatically commits or rolls back
with database.transaction() as tx:
    tx.execute("INSERT INTO users ...")
# Transaction is automatically committed or rolled back

# Lock management - automatically releases lock
lock = threading.Lock()
with lock:
    # Critical section
    shared_resource.modify()
# Lock is automatically released
```

**Custom context manager:**

```python
from contextlib import contextmanager
from typing import Generator

@contextmanager
def temporary_directory() -> Generator[Path, None, None]:
    """Create a temporary directory that's cleaned up after use."""
    import tempfile
    import shutil

    temp_dir = Path(tempfile.mkdtemp())
    try:
        yield temp_dir  # Provide directory to caller
    finally:
        shutil.rmtree(temp_dir)  # Always cleanup

# Usage
with temporary_directory() as temp_dir:
    # Work with temporary directory
    (temp_dir / "file.txt").write_text("data")
# Directory is automatically deleted here
```

### Pathlib for File Operations

**Use `pathlib.Path`** instead of string manipulation:

```python
from pathlib import Path

# Good: Using pathlib
config_dir = Path.home() / ".config" / "myapp"
config_file = config_dir / "settings.json"

# Create directory if needed
config_dir.mkdir(parents=True, exist_ok=True)

# Read file
if config_file.exists():
    content = config_file.read_text()

# Write file
config_file.write_text('{"setting": "value"}')

# Iterate over files
for file in config_dir.glob("*.json"):
    print(file.name)

# Bad: String manipulation
import os
config_dir = os.path.join(os.path.expanduser("~"), ".config", "myapp")
config_file = os.path.join(config_dir, "settings.json")
```

## Performance Best Practices

### List Comprehensions vs Loops

**Prefer list comprehensions for simple transformations:**

```python
# Slower: Traditional loop
result = []
for item in items:
    result.append(item * 2)

# Faster: List comprehension
result = [item * 2 for item in items]

# Even faster for large datasets: Generator expression
result = (item * 2 for item in items)  # Lazy evaluation
```

### Generator Expressions

**Use generators for large datasets to save memory:**

```python
# Bad: Loads entire result set into memory
def get_all_records():
    records = []
    for row in database.query("SELECT * FROM large_table"):
        records.append(process_row(row))
    return records

# Good: Yields records one at a time
def get_all_records():
    for row in database.query("SELECT * FROM large_table"):
        yield process_row(row)

# Usage
for record in get_all_records():
    # Process one record at a time
    print(record)
```

### String Concatenation

**Use join() for multiple strings:**

```python
# Slow: String concatenation in loop
result = ""
for item in items:
    result += str(item) + ", "

# Fast: Use join()
result = ", ".join(str(item) for item in items)

# For complex string building: Use f-strings or io.StringIO
from io import StringIO
buffer = StringIO()
for item in items:
    buffer.write(f"{item}, ")
result = buffer.getvalue()
```

### Dictionary and Set Operations

**Use appropriate data structures:**

```python
# Slow: Check membership in list (O(n))
if item in my_list:  # Linear search
    pass

# Fast: Check membership in set (O(1))
my_set = set(my_list)
if item in my_set:  # Hash lookup
    pass

# Use dict.get() with default instead of checking keys
# Slow
if key in my_dict:
    value = my_dict[key]
else:
    value = default

# Fast
value = my_dict.get(key, default)

# Use setdefault for initialization
# Slow
if key not in my_dict:
    my_dict[key] = []
my_dict[key].append(value)

# Fast
my_dict.setdefault(key, []).append(value)
```

### Avoid Global Lookups in Loops

**Cache global references in local variables:**

```python
import math

# Slower: Global lookup each iteration
def calculate_distances(points):
    distances = []
    for x, y in points:
        distances.append(math.sqrt(x**2 + y**2))
    return distances

# Faster: Cache global reference
def calculate_distances(points):
    sqrt = math.sqrt  # Local reference
    distances = []
    for x, y in points:
        distances.append(sqrt(x**2 + y**2))
    return distances

# Even better: Use list comprehension
def calculate_distances(points):
    sqrt = math.sqrt
    return [sqrt(x**2 + y**2) for x, y in points]
```

### Use Built-in Functions

**Built-in functions are implemented in C and are faster:**

```python
# Slower: Manual implementation
total = 0
for item in items:
    total += item

# Faster: Built-in sum()
total = sum(items)

# Slower: Manual max finding
max_value = items[0]
for item in items[1:]:
    if item > max_value:
        max_value = item

# Faster: Built-in max()
max_value = max(items)

# Use map() for simple transformations (but list comprehension often clearer)
result = list(map(str.upper, strings))
# vs
result = [s.upper() for s in strings]  # More Pythonic
```

### Slots for Memory Optimization

**Use `__slots__` for classes with many instances:**

```python
# Without slots: Each instance has a __dict__
class Point:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

# With slots: More memory efficient, faster attribute access
class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

# Memory savings significant with millions of instances
points = [Point(i, i*2) for i in range(1_000_000)]
```

### Profiling

**Profile before optimizing:**

```python
import cProfile
import pstats
from pstats import SortKey

def main():
    # Your code here
    pass

# Profile execution
cProfile.run('main()', 'profile_stats')

# Analyze results
p = pstats.Stats('profile_stats')
p.sort_stats(SortKey.CUMULATIVE)
p.print_stats(10)  # Top 10 functions by cumulative time

# Or use line_profiler for line-by-line profiling
# pip install line_profiler
# @profile decorator on function
# kernprof -l -v script.py
```

### Lazy Evaluation

**Defer expensive operations until needed:**

```python
from functools import lru_cache, cached_property

class DataProcessor:
    def __init__(self, data_source: str):
        self.data_source = data_source
        self._data = None  # Lazy load

    @property
    def data(self):
        """Lazy load data only when accessed."""
        if self._data is None:
            self._data = self._load_data()
        return self._data

    def _load_data(self):
        # Expensive operation
        return load_from_source(self.data_source)

    @cached_property
    def processed_data(self):
        """Cached property - computed once, cached forever."""
        return expensive_processing(self.data)

    @lru_cache(maxsize=128)
    def get_filtered_data(self, filter_key: str):
        """Memoized method - results cached by arguments."""
        return [item for item in self.data if item.key == filter_key]
```

### Avoid Premature Optimization

**Follow this priority:**

1. **Correct**: Make it work
2. **Clear**: Make it readable
3. **Fast**: Make it fast (only if needed)

**When to optimize:**

- After profiling identifies bottlenecks
- When performance requirements aren't met
- When dealing with large datasets or high-frequency operations

**Quote to remember:** *"Premature optimization is the root of all evil."* — Donald Knuth

## Testing and Tooling

### Pytest Basics

**What it is:** A testing framework that makes it easy to write and run tests.

**Basic structure:**

```python
# File: test_calculator.py

def add(a: int, b: int) -> int:
    return a + b

# Test function (must start with "test_")
def test_add_positive_numbers():
    result = add(2, 3)
    assert result == 5

def test_add_negative_numbers():
    result = add(-1, -1)
    assert result == -2

def test_add_zero():
    result = add(5, 0)
    assert result == 5
```

**Run tests:**

```bash
pytest test_calculator.py
```

#### Parallel test execution

```bash
pip install pytest-xdist

# Run tests across available CPUs
pytest -n auto
```

#### Deterministic tests

```python
import random

def setup_module():
    random.seed(1337)

def test_example():
    assert sorted([random.random() for _ in range(3)])
```

### Fixtures for Reusable Setup

**What they are:** Functions that provide test data or setup/teardown logic.

```python
import pytest
from pathlib import Path

@pytest.fixture
def temp_file(tmp_path: Path) -> Path:
    """Create a temporary file for testing."""
    file = tmp_path / "test.txt"
    file.write_text("test data")
    return file

def test_read_file(temp_file: Path):
    """Test uses the fixture."""
    content = temp_file.read_text()
    assert content == "test data"
```

### Mocking External Dependencies

**Why:** Tests should be fast and not depend on external services.

```python
from unittest.mock import Mock, patch
import requests

def get_user_data(user_id: int) -> dict:
    """Fetch user data from API."""
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

def test_get_user_data():
    """Test without making real HTTP request."""
    with patch('requests.get') as mock_get:
        # Configure mock
        mock_get.return_value.json.return_value = {
            "id": 1,
            "name": "Alice"
        }

        # Call function
        result = get_user_data(1)

        # Verify
        assert result["name"] == "Alice"
        mock_get.assert_called_once_with("https://api.example.com/users/1")
```

### Test Markers

**Organize tests** by type or requirements:

```python
import pytest

@pytest.mark.unit
def test_calculation():
    """Fast unit test."""
    assert 2 + 2 == 4

@pytest.mark.integration
def test_database_connection():
    """Slower integration test."""
    db = connect_to_database()
    assert db.is_connected()

@pytest.mark.slow
def test_large_dataset():
    """Very slow test."""
    process_million_records()
```

**Run specific tests:**

```bash
pytest -m unit          # Run only unit tests
pytest -m "not slow"    # Skip slow tests
```

### Coverage Measurement

**Track which code is tested:**

```bash
# Install coverage tool
pip install pytest-cov

# Run tests with coverage
pytest --cov=myapp --cov-report=html

# View report
open htmlcov/index.html
```

## Security and Compliance

### Input Validation with Pydantic

**Always validate external input:**

```python
from pydantic import (
    BaseModel,
    EmailStr,
    Field,
    field_validator,
    ValidationError,
)

class UserRegistration(BaseModel):
    username: str = Field(min_length=3, max_length=20)
    email: EmailStr  # Validates email format
    age: int = Field(ge=18, le=120)  # Greater or equal to 18, less or equal to 120
    password: str = Field(min_length=8)

    @field_validator("username")
    @classmethod
    def username_alphanumeric(cls, v: str) -> str:
        """Ensure username is alphanumeric."""
        if not v.isalnum():
            raise ValueError("Username must be alphanumeric")
        return v

    @field_validator("password")
    @classmethod
    def password_strength(cls, v: str) -> str:
        """Ensure password has minimum strength."""
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain uppercase letter")
        if not any(c.isdigit() for c in v):
            raise ValueError("Password must contain digit")
        return v

# Usage
try:
    user = UserRegistration(
        username="alice123",
        email="alice@example.com",
        age=25,
        password="SecurePass123"
    )
except ValidationError as e:
    print(e.json())
```

### Safe Subprocess Execution

**Avoid shell injection vulnerabilities:**

```python
import subprocess

# Bad: Shell injection vulnerability
user_input = "file.txt; rm -rf /"
subprocess.run(f"cat {user_input}", shell=True)  # DANGEROUS!

# Good: Safe execution with list of arguments
user_input = "file.txt"
subprocess.run(["cat", user_input], check=True, capture_output=True)

# Good: Validate input before using
import re

def is_safe_filename(filename: str) -> bool:
    """Check if filename is safe."""
    return bool(re.match(r'^[a-zA-Z0-9_.-]+$', filename))

if is_safe_filename(user_input):
    subprocess.run(["cat", user_input], check=True)
else:
    raise ValueError("Invalid filename")
```

### Dependency Scanning

**Regularly check for vulnerabilities:**

```bash
# Install pip-audit
pip install pip-audit

# Scan dependencies
pip-audit

# Example output:
# Found 2 known vulnerabilities in 1 package
# Name    Version  ID              Fix Versions
# ------  -------  --------------  ------------
# urllib3 1.26.0   PYSEC-2021-108  1.26.5
```

## Documentation and Discoverability

### Module-Level Docstrings

**Every module should explain its purpose:**

```python
"""User authentication and authorization module.

This module provides functions for:
- User login and logout
- Password hashing and verification
- Session management
- Role-based access control

Dependencies:
- bcrypt for password hashing
- redis for session storage

Example:
    >>> from auth import authenticate_user
    >>> user = authenticate_user("alice", "password123")
    >>> if user:
    ...     print(f"Welcome, {user.name}!")
"""

import bcrypt
import redis
```

### Function Docstrings

**Document what functions do, their parameters, and return values:**

```python
def calculate_discount(price: float, discount_percent: float, is_member: bool = False) -> float:
    """Calculate final price after applying discount.

    Args:
        price: Original price in dollars
        discount_percent: Discount percentage (0-100)
        is_member: Whether customer is a member (gets extra 5% off)

    Returns:
        Final price after discount

    Raises:
        ValueError: If price is negative or discount is not in range 0-100

    Examples:
        >>> calculate_discount(100.0, 10.0)
        90.0
        >>> calculate_discount(100.0, 10.0, is_member=True)
        85.5
    """
    if price < 0:
        raise ValueError("Price cannot be negative")
    if not 0 <= discount_percent <= 100:
        raise ValueError("Discount must be between 0 and 100")

    discount = price * (discount_percent / 100)
    if is_member:
        discount += price * 0.05

    return price - discount
```

### Class Docstrings

**Document class purpose and usage:**

```python
class DatabaseConnection:
    """Manage database connections with automatic retry and connection pooling.

    This class provides a context manager interface for database operations
    and handles connection failures with exponential backoff retry logic.

    Attributes:
        host: Database server hostname
        port: Database server port
        max_retries: Maximum number of connection retry attempts
        pool_size: Number of connections to maintain in pool

    Example:
        >>> with DatabaseConnection("localhost", 5432) as db:
        ...     result = db.execute("SELECT * FROM users")
        ...     for row in result:
        ...         print(row)
    """

    def __init__(self, host: str, port: int, max_retries: int = 3, pool_size: int = 10):
        """Initialize database connection manager.

        Args:
            host: Database server hostname
            port: Database server port
            max_retries: Maximum connection retry attempts (default: 3)
            pool_size: Connection pool size (default: 10)
        """
        self.host = host
        self.port = port
        self.max_retries = max_retries
        self.pool_size = pool_size
```

## Maintenance

- Revisit this document whenever language versions, linters, or project requirements change.
- Record updates with dates and a short rationale in the version history section below.

## Version History

### 1.1.0 (2025-11-07)

- Added comprehensive Performance Best Practices section
- Added list comprehensions vs loops guidance
- Added generator expressions for memory efficiency
- Added string concatenation best practices
- Added dictionary and set operation optimizations
- Added profiling guidance with cProfile
- Added lazy evaluation patterns with lru_cache and cached_property
- Added **slots** for memory optimization
- Enhanced with real-world performance examples and Big-O considerations

### 1.0.0 (2025-11-07)

- Initial publication (extracted from unified coding standards)
- Added researched best practices for security, documentation, tooling, and CI coverage
- Enhanced with detailed explanations, examples, and definitions for beginner programmers

<!-- End of document -->
