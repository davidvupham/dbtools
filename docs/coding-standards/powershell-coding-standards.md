# PowerShell Coding Standards

> Version: 1.1.0
>
> Purpose: Define required practices for PowerShell code generation and refactoring
>
> Last Updated: 2025-11-07

## Scope

These standards apply to all PowerShell code within this repository, whether written by humans or generated by AI. They supplement existing project conventions and override ad-hoc preferences when conflicts arise.

## Table of Contents

- [General Expectations](#general-expectations)
  - [Deterministic Behavior](#deterministic-behavior)
  - [Idempotent Operations](#idempotent-operations)
  - [Secret Management](#secret-management)
  - [Version Pinning](#version-pinning)
- [Style and Structure](#style-and-structure)
  - [PowerShell Version](#powershell-version)
  - [File Encoding](#file-encoding)
  - [Strict Mode](#strict-mode)
  - [Script Structure](#script-structure)
  - [Indentation and Braces](#indentation-and-braces)
  - [Line Length](#line-length)
- [Naming Conventions](#naming-conventions)
  - [PascalCase](#pascalcase)
  - [Approved Verbs](#approved-verbs)
  - [Variable Names](#variable-names)
  - [Constants and Configuration](#constants-and-configuration)
  - [Scope and Variables](#scope-and-variables)
  - [Comparison Operators](#comparison-operators)
  - [Complete Example](#complete-example)
- [Parameters and Types](#parameters-and-types)
  - [CmdletBinding and Parameters](#cmdletbinding-and-parameters)
  - [Parameter Validation](#parameter-validation)
  - [Type Constraints](#type-constraints)
  - [Strongly Typed Objects](#strongly-typed-objects)
  - [PowerShell Classes](#powershell-classes)
- [Pipeline Support](#pipeline-support)
  - [Understanding the Pipeline](#understanding-the-pipeline)
  - [Begin, Process, End Blocks](#begin-process-end-blocks)
  - [Pipeline Input Options](#pipeline-input-options)
  - [Pipeline Best Practices](#pipeline-best-practices)
- [Output and Return Values](#output-and-return-values)
  - [Output Methods](#output-methods)
  - [Best Practices for Output](#best-practices-for-output)
  - [Boolean Return Values](#boolean-return-values)
  - [Suppress Unwanted Output](#suppress-unwanted-output)
- [Error Handling and Logging](#error-handling-and-logging)
  - [Error Action Preference](#error-action-preference)
  - [Try-Catch-Finally](#try-catch-finally)
  - [Error Records](#error-records)
  - [Logging Cmdlets](#logging-cmdlets)
  - [Structured Logging](#structured-logging)
- [Performance Best Practices](#performance-best-practices)
  - [Array Building](#array-building)
  - [String Building](#string-building)
  - [Filtering and Where-Object](#filtering-and-where-object)
  - [ForEach vs ForEach-Object](#foreach-vs-foreach-object)
  - [Avoid Repeated Cmdlet Calls](#avoid-repeated-cmdlet-calls)
  - [Use -Filter Instead of -Include](#use--filter-instead-of--include)
  - [Measure Performance](#measure-performance)
  - [Regex Performance](#regex-performance)
  - [Parallel Processing](#parallel-processing)
- [Testing and Tooling](#testing-and-tooling)
  - [Pester Basics](#pester-basics)
  - [Pester Assertions](#pester-assertions)
  - [Mocking](#mocking)
  - [Script Analyzer](#script-analyzer)
- [Security and Compliance](#security-and-compliance)
  - [Credential Management](#credential-management)
  - [Just Enough Administration (JEA)](#just-enough-administration-jea)
  - [Input Validation](#input-validation)
  - [Avoid Command Injection](#avoid-command-injection)
  - [Code Signing](#code-signing)
- [Documentation and Discoverability](#documentation-and-discoverability)
  - [Comment-Based Help](#comment-based-help)
  - [Module Documentation](#module-documentation)
  - [Inline Comments](#inline-comments)

## General Expectations

### Deterministic Behavior

**What it means:** Scripts should produce the same output given the same input, without unexpected side effects.

**Why it matters:** Makes scripts predictable, testable, and easier to debug.

**Example:**

```powershell
# Good: Deterministic - always returns same result for same input
function Get-TotalPrice {
    param(
        [decimal]$Price,
        [decimal]$TaxRate
    )
    return $Price * (1 + $TaxRate)
}

# Bad: Non-deterministic - result depends on external state
$script:Total = 0
function Add-ToTotal {
    param([decimal]$Amount)
    $script:Total += $Amount
    return $script:Total
}
```

### Idempotent Operations

**What it means:** An operation that can be applied multiple times without changing the result beyond the initial application.

**Why it matters:** Makes scripts more resilient and safe to retry.

**Example:**

```powershell
# Good: Idempotent - can run multiple times safely
function Ensure-DirectoryExists {
    param([string]$Path)

    if (-not (Test-Path $Path)) {
        New-Item -Path $Path -ItemType Directory -Force | Out-Null
    }
}

# Bad: Not idempotent - fails on second run
function Create-Directory {
    param([string]$Path)
    New-Item -Path $Path -ItemType Directory  # Throws error if exists
}
```

### Secret Management

- **Never** hard-code passwords, API keys, tokens, or credentials in scripts
- Use `Get-Secret` from Microsoft.PowerShell.SecretManagement module
- Use HashiCorp Vault for secret management
- Use `ConvertTo-SecureString` for sensitive strings

**Example:**

```powershell
# Bad: Hard-coded credential
$password = "MyPassword123"

# Good: Retrieve from secure storage
$password = Get-Secret -Name "MyAppPassword" -AsPlainText

# Good: Use SecureString
$securePassword = Read-Host "Enter password" -AsSecureString
$credential = New-Object System.Management.Automation.PSCredential("username", $securePassword)
```

### Version Pinning

**Why:** Ensures reproducible builds and prevents unexpected breakage.

**How:** Specify module versions in manifests and use `#Requires`:

```powershell
#Requires -Version 7.0
#Requires -Modules @{ ModuleName="Pester"; ModuleVersion="5.3.0" }
```

## Style and Structure

### PowerShell Version

**Target PowerShell 7+** for cross-platform compatibility and modern features.

**Declare requirements:**

```powershell
#Requires -Version 7.0
#Requires -PSEdition Core
```

### File Encoding

**Save all scripts as UTF-8 without BOM** (Byte Order Mark).

**Why:** Ensures compatibility across platforms and prevents parsing issues.

**How to check in VS Code:**

- Look at bottom right corner
- Should show "UTF-8" not "UTF-8 with BOM"

### Strict Mode

**Enable strict mode** to catch common errors:

```powershell
Set-StrictMode -Version Latest
```

**What it catches:**

- References to uninitialized variables
- References to non-existent properties
- Function calls with incorrect syntax

### Script Structure

**Organize scripts into logical sections:**

```powershell
<#
.SYNOPSIS
    Brief description of script purpose
#>

#Requires -Version 7.0
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# ============================================================================
# Parameters
# ============================================================================

param(
    [Parameter(Mandatory)]
    [string]$ServerName,

    [int]$Port = 8080
)

# ============================================================================
# Functions
# ============================================================================

function Get-ServerStatus {
    # Function implementation
}

# ============================================================================
# Main Script Logic
# ============================================================================

try {
    $status = Get-ServerStatus -Server $ServerName -Port $Port
    Write-Output "Server status: $status"
}
catch {
    Write-Error "Failed to get server status: $_"
    exit 1
}
```

### Indentation and Braces

**Use consistent indentation and brace placement:**

```powershell
# Good: Opening brace on same line (K&R style - PowerShell convention)
function Get-Data {
    if ($condition) {
        # Code here
    }
    else {
        # Code here
    }
}

# Acceptable: Allman style (opening brace on new line)
function Get-Data
{
    if ($condition)
    {
        # Code here
    }
    else
    {
        # Code here
    }
}

# Important: Be consistent within a project
```

### Line Length

**Keep lines under 115 characters** for readability.

**Use splatting for long parameter lists:**

```powershell
# Bad: Long line
New-AzVM -ResourceGroupName "MyResourceGroup" -Name "MyVM" -Location "EastUS" -VirtualNetworkName "MyVNet" -SubnetName "MySubnet" -SecurityGroupName "MyNSG" -PublicIpAddressName "MyPublicIP"

# Good: Splatting
$vmParams = @{
    ResourceGroupName     = "MyResourceGroup"
    Name                  = "MyVM"
    Location              = "EastUS"
    VirtualNetworkName    = "MyVNet"
    SubnetName            = "MySubnet"
    SecurityGroupName     = "MyNSG"
    PublicIpAddressName   = "MyPublicIP"
}
New-AzVM @vmParams
```

## Naming Conventions

PowerShell uses specific naming conventions to maintain consistency:

### PascalCase

**What it is:** Each word starts with a capital letter, no separators.

**Used for:** Functions, cmdlets, classes, and enum values.

**Examples:**

```powershell
# Function names (Verb-Noun format)
function Get-UserAccount { }
function Set-DatabaseConnection { }
function Test-NetworkConnectivity { }

# Class names
class UserAccount { }
class DatabaseConnection { }

# Enum values
enum Status {
    Active
    Inactive
    Pending
}
```

### Approved Verbs

**PowerShell has approved verbs** for consistency. Use `Get-Verb` to see the list.

**Common approved verbs:**

- `Get`: Retrieve data
- `Set`: Modify data
- `New`: Create new resource
- `Remove`: Delete resource
- `Start`: Begin operation
- `Stop`: End operation
- `Test`: Verify condition
- `Invoke`: Perform action
- `Update`: Refresh data
- `Add`: Append to collection
- `Clear`: Remove all items

**Examples:**

```powershell
# Good: Approved verbs
function Get-LogFile { }
function Set-Configuration { }
function Test-Connection { }
function Invoke-Deployment { }

# Bad: Non-approved verbs
function Fetch-LogFile { }      # Use Get-LogFile
function Change-Configuration { } # Use Set-Configuration
function Check-Connection { }    # Use Test-Connection
function Run-Deployment { }      # Use Invoke-Deployment or Start-Deployment
```

### Variable Names

**Use PascalCase for variables** (PowerShell convention):

```powershell
# Variables
$UserName = "Alice"
$TotalCount = 42
$IsActive = $true
$DatabaseConnection = $null

# Arrays
$UserList = @("Alice", "Bob", "Charlie")
$ServerNames = @("Server01", "Server02")

# Hashtables
$UserInfo = @{
    Name = "Alice"
    Age = 30
    Email = "alice@example.com"
}
```

Note: Some teams prefer lowerCamelCase for variables and PascalCase for functions/parameters. This repository standardizes on PascalCase for variables; if you adopt a different convention, state it explicitly and apply it consistently.

### Constants and Configuration

**Use PascalCase with descriptive names:**

```powershell
# Script-level constants
$MaxRetryAttempts = 3
$DefaultTimeout = 30
$ApiBaseUrl = "https://api.example.com"
```

### Scope and Variables

**Understand PowerShell scopes:**

```powershell
# Script scope (visible to entire script)
$script:ConnectionString = "Server=localhost"

# Global scope (visible everywhere, use sparingly)
$global:AppVersion = "1.0.0"

# Local scope (default, visible in current scope only)
$localVar = "value"

# Private scope (not visible to child scopes)
$private:secretKey = "key123"

# Function with proper scoping
function Set-Configuration {
    param([string]$Value)

    # Modify script-level variable
    $script:ConnectionString = $Value

    # Local variable (doesn't affect outer scope)
    $tempValue = $Value.ToUpper()
}
```

**Best practices:**

- Prefer parameter passing over global variables
- Use `$script:` for module-level state
- Avoid `$global:` except for truly global configuration
- Initialize variables before use (StrictMode will catch this)

### Comparison Operators

**Use proper comparison operators:**

```powershell
# Equality
$value -eq 5          # Equal
$value -ne 5          # Not equal
$value -gt 5          # Greater than
$value -lt 5          # Less than
$value -ge 5          # Greater or equal
$value -le 5          # Less or equal

# String comparisons (case-insensitive by default)
$name -eq "alice"     # Case-insensitive
$name -ceq "Alice"    # Case-sensitive
$name -like "ali*"    # Wildcard match
$name -match "^ali"   # Regex match

# Collection operators
$array -contains "item"    # Array contains value
"item" -in $array          # Value in array
$array -notcontains "item" # Array doesn't contain value

# Type checking
$value -is [string]        # Check type
$value -isnot [int]        # Check not type

# Logical operators
$a -and $b            # Logical AND
$a -or $b             # Logical OR
-not $a               # Logical NOT
!$a                   # Logical NOT (alternative)
```

### Complete Example

```powershell
# Script: Manage-UserAccount.ps1

#Requires -Version 7.0
Set-StrictMode -Version Latest

# Constants
$MaxLoginAttempts = 3
$SessionTimeoutMinutes = 60

# Function
function Get-UserAccount {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$UserName
    )

    # Local variables
    $IsValid = $false
    $AttemptCount = 0

    # Function logic...
    return $IsValid
}
```

## Parameters and Types

### CmdletBinding and Parameters

**Use `[CmdletBinding()]`** to enable advanced function features:

```powershell
function Get-UserData {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Mandatory parameter with type
        [Parameter(Mandatory)]
        [string]$UserName,

        # Optional parameter with default
        [int]$MaxResults = 100,

        # Parameter from pipeline
        [Parameter(ValueFromPipeline)]
        [string]$ComputerName,

        # Switch parameter (boolean flag)
        [switch]$IncludeDisabled
    )

    process {
        if ($PSCmdlet.ShouldProcess($UserName, "Get user data")) {
            # Implementation
        }
    }
}
```

When to implement `ShouldProcess`/`-WhatIf`/`-Confirm`:

- Add `SupportsShouldProcess` for any function that changes system state (files, services, registry, cloud resources).
- Use `$PSCmdlet.ShouldProcess(target, action)` before the state change to honor `-WhatIf` and `-Confirm`.

**What `[CmdletBinding()]` enables:**

- `-Verbose` and `-Debug` parameters
- `-ErrorAction` and `-WarningAction` parameters
- `ShouldProcess` for `-WhatIf` and `-Confirm`
- Pipeline support with `begin`, `process`, `end` blocks

### Parameter Validation

**Validate input at the parameter level:**

```powershell
function Set-ServerConfiguration {
    param(
        # Must be one of these values
        [ValidateSet("Development", "Staging", "Production")]
        [string]$Environment,

        # Must be in range 1-65535
        [ValidateRange(1, 65535)]
        [int]$Port,

        # Must be a valid IP address
        [ValidateScript({ [System.Net.IPAddress]::TryParse($_, [ref]$null) })]
        [string]$IPAddress,

        # Cannot be null or empty
        [ValidateNotNullOrEmpty()]
        [string]$ServerName,

        # Must pass custom validation
        [ValidateScript({ Test-Path $_ })]
        [string]$ConfigPath
    )
}

# Usage examples
Set-ServerConfiguration -Environment "Production" -Port 8080 -IPAddress "192.168.1.1" -ServerName "Server01" -ConfigPath "C:\config.json"
```

### Type Constraints

**Use explicit types** for better error messages and validation:

```powershell
function Process-Data {
    param(
        # String type
        [string]$Name,

        # Integer type
        [int]$Count,

        # Boolean type
        [bool]$IsEnabled,

        # DateTime type
        [datetime]$StartDate,

        # Array of strings
        [string[]]$Tags,

        # Hashtable
        [hashtable]$Settings,

        # Custom object type
        [System.IO.FileInfo]$File,

        # Nullable integer
        [Nullable[int]]$OptionalCount
    )
}
```

### Strongly Typed Objects

**Prefer PSCustomObject over hashtables** for structured data:

```powershell
# Good: Strongly typed object
$user = [PSCustomObject]@{
    PSTypeName = 'UserAccount'
    Id         = 1
    Name       = 'Alice'
    Email      = 'alice@example.com'
    IsActive   = $true
}

# Access properties with IntelliSense support
$user.Name
$user.Email

# Bad: Loosely typed hashtable
$user = @{
    Id = 1
    Name = 'Alice'
    Email = 'alice@example.com'
    IsActive = $true
}
```

### PowerShell Classes

**Use classes for complex types:**

```powershell
class UserAccount {
    # Properties
    [int]$Id
    [string]$Name
    [string]$Email
    [bool]$IsActive

    # Constructor
    UserAccount([int]$id, [string]$name, [string]$email) {
        $this.Id = $id
        $this.Name = $name
        $this.Email = $email
        $this.IsActive = $true
    }

    # Method
    [void]Deactivate() {
        $this.IsActive = $false
    }

    # Method with return value
    [string]GetDisplayName() {
        return "$($this.Name) <$($this.Email)>"
    }
}

# Usage
$user = [UserAccount]::new(1, "Alice", "alice@example.com")
$user.Deactivate()
Write-Output $user.GetDisplayName()
```

## Pipeline Support

### Understanding the Pipeline

**What it is:** PowerShell's pipeline allows objects to flow from one command to another, enabling powerful data processing chains.

**Why it matters:** Proper pipeline support makes functions composable and follows PowerShell conventions.

### Begin, Process, End Blocks

**Use these blocks for pipeline-aware functions:**

```powershell
function Convert-Temperature {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [double]$Celsius
    )

    begin {
        # Runs once before processing pipeline input
        Write-Verbose "Starting temperature conversion"
        $conversionCount = 0
    }

    process {
        # Runs once for each pipeline object
        $fahrenheit = ($Celsius * 9/5) + 32
        $conversionCount++

        [PSCustomObject]@{
            Celsius    = $Celsius
            Fahrenheit = $fahrenheit
        }
    }

    end {
        # Runs once after all pipeline input is processed
        Write-Verbose "Converted $conversionCount temperatures"
    }
}

# Usage with pipeline
0, 10, 20, 30 | Convert-Temperature
```

### Pipeline Input Options

**Different ways to accept pipeline input:**

```powershell
function Get-ProcessInfo {
    [CmdletBinding()]
    param(
        # Accept by value (object itself)
        [Parameter(ValueFromPipeline)]
        [string]$ProcessName,

        # Accept by property name
        [Parameter(ValueFromPipelineByPropertyName)]
        [int]$Id,

        # Accept both ways
        [Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string]$Name
    )

    process {
        if ($ProcessName) {
            Get-Process -Name $ProcessName
        }
        elseif ($Id) {
            Get-Process -Id $Id
        }
    }
}

# Usage examples
"notepad", "explorer" | Get-ProcessInfo
Get-Process | Select-Object Id | Get-ProcessInfo
```

### Pipeline Best Practices

**Do:**

- Use `process` block for pipeline input
- Output objects, not formatted text
- Support both parameter and pipeline input
- Use `begin` for setup, `end` for cleanup

**Don't:**

- Use `return` in pipeline functions to emit values (prefer implicit output for composability). Using `return` to exit early is fine.
- Format output inside functions (let user format)
- Collect all pipeline input before processing (defeats streaming)

```powershell
# Bad: Collects all input first
function Process-Items {
    param(
        [Parameter(ValueFromPipeline)]
        [string]$Item
    )

    begin { $allItems = @() }
    process { $allItems += $Item }
    end {
        foreach ($item in $allItems) {
            # Process items
        }
    }
}

# Good: Processes items as they arrive
function Process-Items {
    param(
        [Parameter(ValueFromPipeline)]
        [string]$Item
    )

    process {
        # Process each item immediately
        $Item.ToUpper()
    }
}
```

## Output and Return Values

### Output Methods

**PowerShell has multiple ways to produce output:**

```powershell
function Get-Data {
    # Implicit output (preferred for pipeline)
    "This goes to output stream"
    Get-Process | Select-Object -First 1

    # Explicit output (same as implicit)
    Write-Output "Explicit output"

    # Return (exits function immediately)
    return "Final value"

    # This line never executes
    "Never seen"
}
```

### Best Practices for Output

**Use implicit output for objects:**

```powershell
# Good: Implicit output of objects
function Get-UserList {
    [CmdletBinding()]
    param()

    $users = @(
        [PSCustomObject]@{ Name = "Alice"; Age = 30 }
        [PSCustomObject]@{ Name = "Bob"; Age = 25 }
    )

    # Output objects (no Write-Output needed)
    $users
}

# Usage: Can be piped to other commands
Get-UserList | Where-Object Age -gt 26
```

**Avoid Write-Host (except for UI):**

```powershell
# Bad: Write-Host cannot be captured or piped
function Show-Status {
    Write-Host "Processing..." -ForegroundColor Green
    Write-Host "Complete!" -ForegroundColor Green
}

# Good: Use Write-Information or Write-Verbose
function Show-Status {
    [CmdletBinding()]
    param()

    Write-Information "Processing..." -InformationAction Continue
    Write-Verbose "Complete!"
}

# Good: Write-Host only for interactive UI
function Show-Menu {
    Write-Host "=== Main Menu ===" -ForegroundColor Cyan
    Write-Host "1. Option 1"
    Write-Host "2. Option 2"
    $choice = Read-Host "Select option"
}
```

### Boolean Return Values

**Use proper boolean returns:**

```powershell
# Good: Clear boolean logic
function Test-FileIsValid {
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [string]$Path
    )

    if (-not (Test-Path $Path)) {
        return $false
    }

    $file = Get-Item $Path
    if ($file.Length -eq 0) {
        return $false
    }

    return $true
}

# Usage in conditionals
if (Test-FileIsValid -Path "data.txt") {
    # Process file
}
```

### Suppress Unwanted Output

**Prevent cmdlets from producing output:**

```powershell
# Method 1: Pipe to Out-Null (slowest)
New-Item -Path "temp.txt" -ItemType File | Out-Null

# Method 2: Cast to [void] (fast)
[void](New-Item -Path "temp.txt" -ItemType File)

# Method 3: Assign to $null (fastest)
$null = New-Item -Path "temp.txt" -ItemType File

# Method 4: Redirect to $null (fast)
New-Item -Path "temp.txt" -ItemType File > $null
```

## Error Handling and Logging

### Error Action Preference

**Set error behavior explicitly:**

```powershell
# Stop on any error (recommended for scripts)
$ErrorActionPreference = 'Stop'

# Continue on errors (default)
$ErrorActionPreference = 'Continue'

# Suppress errors (rarely recommended)
$ErrorActionPreference = 'SilentlyContinue'
```

### Try-Catch-Finally

**Handle errors gracefully:**

```powershell
function Get-FileContent {
    param([string]$Path)

    try {
        # Attempt operation
        $content = Get-Content -Path $Path -ErrorAction Stop
        return $content
    }
    catch [System.IO.FileNotFoundException] {
        # Handle specific exception
        Write-Error "File not found: $Path"
        return $null
    }
    catch [System.UnauthorizedAccessException] {
        # Handle another specific exception
        Write-Error "Access denied: $Path"
        return $null
    }
    catch {
        # Handle any other exception
        Write-Error "Failed to read file: $_"
        throw  # Re-throw if you can't handle it
    }
    finally {
        # Always runs (cleanup code)
        Write-Verbose "Completed file read attempt"
    }
}
```

### Error Records

**Create detailed error records:**

```powershell
function Invoke-DatabaseQuery {
    param([string]$Query)

    try {
        # Database operation
    }
    catch {
        $errorRecord = [System.Management.Automation.ErrorRecord]::new(
            [Exception]::new("Database query failed: $Query"),
            "DatabaseQueryFailed",                    # Error ID
            [System.Management.Automation.ErrorCategory]::OperationStopped,
            $Query                                     # Target object
        )

        $PSCmdlet.WriteError($errorRecord)
    }
}
```

### Logging Cmdlets

**Use appropriate output streams:**

```powershell
function Process-Data {
    [CmdletBinding()]
    param([string]$Data)

    # Information: General progress messages
    Write-Information "Processing data: $Data" -InformationAction Continue

    # Verbose: Detailed diagnostic information
    Write-Verbose "Validating data format"

    # Debug: Developer diagnostic information
    Write-Debug "Data length: $($Data.Length)"

    # Warning: Non-fatal issues
    Write-Warning "Data contains deprecated format"

    # Error: Fatal issues
    Write-Error "Data validation failed"

    # Output: Actual results (goes to pipeline)
    Write-Output $processedData
}

# Usage
Process-Data -Data "test" -Verbose -Debug
```

### Structured Logging

**Create structured log entries:**

```powershell
function Write-StructuredLog {
    param(
        [ValidateSet("Info", "Warning", "Error")]
        [string]$Level,

        [string]$Message,

        [hashtable]$Properties = @{}
    )

    $logEntry = [PSCustomObject]@{
        Timestamp  = Get-Date -Format "o"
        Level      = $Level
        Message    = $Message
        Properties = $Properties
        Computer   = $env:COMPUTERNAME
        User       = $env:USERNAME
    }

    # Output as JSON for log aggregation systems
    $logEntry | ConvertTo-Json -Compress | Out-File -Append -FilePath "app.log"
}

# Usage
Write-StructuredLog -Level "Info" -Message "User logged in" -Properties @{
    UserId = 123
    IPAddress = "192.168.1.1"
}
```

## Performance Best Practices

### Array Building

**Avoid += for arrays** (creates new array each time):

```powershell
# Bad: Very slow for large collections
$results = @()
foreach ($item in 1..10000) {
    $results += $item * 2
}

# Good: Use ArrayList or List
$results = [System.Collections.ArrayList]::new()
foreach ($item in 1..10000) {
    [void]$results.Add($item * 2)
}

# Good: Use generic List (preferred)
$results = [System.Collections.Generic.List[int]]::new()
foreach ($item in 1..10000) {
    $results.Add($item * 2)
}

# Best: Let PowerShell collect output
$results = foreach ($item in 1..10000) {
    $item * 2
}
```

### String Building

**Use StringBuilder for large string concatenation:**

```powershell
# Bad: Slow for many concatenations
$text = ""
foreach ($line in 1..1000) {
    $text += "Line $line`n"
}

# Good: Use StringBuilder
$sb = [System.Text.StringBuilder]::new()
foreach ($line in 1..1000) {
    [void]$sb.AppendLine("Line $line")
}
$text = $sb.ToString()

# Good: Use -join for simple cases
$lines = foreach ($line in 1..1000) {
    "Line $line"
}
$text = $lines -join "`n"
```

### Filtering and Where-Object

**Use .Where() method for better performance:**

```powershell
# Slower: Pipeline with Where-Object
$largeFiles = Get-ChildItem -Recurse | Where-Object { $_.Length -gt 1MB }

# Faster: .Where() method
$largeFiles = (Get-ChildItem -Recurse).Where{ $_.Length -gt 1MB }

# Even better: Filter at source when possible
$largeFiles = Get-ChildItem -Recurse -File | Where-Object Length -gt 1MB
```

### ForEach vs ForEach-Object

**Understand the difference:**

```powershell
# ForEach-Object: Pipeline, processes one at a time
1..1000 | ForEach-Object { $_ * 2 }

# foreach statement: Faster, but loads all into memory first
foreach ($num in 1..1000) {
    $num * 2
}

# .ForEach() method: Fast and memory efficient
(1..1000).ForEach{ $_ * 2 }
```

### Avoid Repeated Cmdlet Calls

**Cache results when calling cmdlets multiple times:**

```powershell
# Bad: Calls Get-Process multiple times
if ((Get-Process -Name "notepad" -ErrorAction SilentlyContinue).Count -gt 0) {
    $process = Get-Process -Name "notepad"
    Stop-Process -InputObject $process
}

# Good: Call once and cache
$process = Get-Process -Name "notepad" -ErrorAction SilentlyContinue
if ($process) {
    Stop-Process -InputObject $process
}
```

### Use -Filter Instead of -Include

**When using Get-ChildItem and similar cmdlets:**

```powershell
# Slower: Retrieves all, then filters
Get-ChildItem -Path C:\Logs -Include *.log -Recurse

# Faster: Filters at source
Get-ChildItem -Path C:\Logs -Filter *.log -Recurse
```

### Measure Performance

**Use Measure-Command to profile:**

```powershell
# Measure execution time
$time = Measure-Command {
    Get-ChildItem -Recurse | Where-Object Length -gt 1MB
}
Write-Output "Execution time: $($time.TotalSeconds) seconds"

# Compare different approaches
$approach1 = Measure-Command {
    $results = @()
    foreach ($i in 1..1000) { $results += $i }
}

$approach2 = Measure-Command {
    $results = foreach ($i in 1..1000) { $i }
}

Write-Output "Approach 1: $($approach1.TotalMilliseconds)ms"
Write-Output "Approach 2: $($approach2.TotalMilliseconds)ms"
```

### Regex Performance

**Compile regex for repeated use:**

```powershell
# Slow: Recompiles regex each time
foreach ($line in $lines) {
    if ($line -match '\d{3}-\d{2}-\d{4}') {
        # Process
    }
}

# Fast: Compile once
$regex = [regex]::new('\d{3}-\d{2}-\d{4}', [System.Text.RegularExpressions.RegexOptions]::Compiled)
foreach ($line in $lines) {
    if ($regex.IsMatch($line)) {
        # Process
    }
}
```

### Parallel Processing

**Use ForEach-Object -Parallel for CPU-intensive tasks (PowerShell 7+):**

```powershell
# Sequential processing
$results = 1..100 | ForEach-Object {
    Start-Sleep -Milliseconds 100
    $_ * 2
}

# Parallel processing (much faster)
$results = 1..100 | ForEach-Object -Parallel {
    Start-Sleep -Milliseconds 100
    $_ * 2
} -ThrottleLimit 10

# Note: Each parallel runspace is isolated
# Use $using: to access outer scope variables
$multiplier = 3
$results = 1..100 | ForEach-Object -Parallel {
    $_ * $using:multiplier
} -ThrottleLimit 10
```

## Testing and Tooling

### Pester Basics

**What it is:** PowerShell's testing framework for unit and integration tests.

**Basic structure:**

```powershell
# File: Get-UserAccount.Tests.ps1

BeforeAll {
    # Import module or dot-source script
    . $PSScriptRoot/Get-UserAccount.ps1
}

Describe "Get-UserAccount" {
    Context "When user exists" {
        It "Returns user object" {
            $result = Get-UserAccount -UserName "alice"
            $result | Should -Not -BeNullOrEmpty
            $result.Name | Should -Be "alice"
        }
    }

    Context "When user does not exist" {
        It "Returns null" {
            $result = Get-UserAccount -UserName "nonexistent"
            $result | Should -BeNullOrEmpty
        }
    }

    Context "Parameter validation" {
        It "Throws when UserName is empty" {
            { Get-UserAccount -UserName "" } | Should -Throw
        }
    }
}
```

**Run tests:**

```powershell
Invoke-Pester -Path ./Get-UserAccount.Tests.ps1
```

### Pester Assertions

**Common assertion patterns:**

```powershell
Describe "Assertion Examples" {
    It "Tests equality" {
        $result = 2 + 2
        $result | Should -Be 4
    }

    It "Tests type" {
        $result = Get-Date
        $result | Should -BeOfType [DateTime]
    }

    It "Tests null" {
        $result = $null
        $result | Should -BeNullOrEmpty
    }

    It "Tests string content" {
        $result = "Hello World"
        $result | Should -Match "World"
        $result | Should -BeLike "*World*"
    }

    It "Tests collections" {
        $result = @(1, 2, 3)
        $result | Should -Contain 2
        $result | Should -HaveCount 3
    }

    It "Tests file existence" {
        "C:\Windows\System32\notepad.exe" | Should -Exist
    }

    It "Tests exceptions" {
        { throw "Error" } | Should -Throw
        { throw "Error" } | Should -Throw -ExpectedMessage "Error"
    }
}
```

### Mocking

**Mock external dependencies:**

```powershell
Describe "Get-ServerStatus" {
    BeforeAll {
        function Get-ServerStatus {
            param([string]$Server)
            $response = Invoke-RestMethod -Uri "http://$Server/status"
            return $response.status
        }
    }

    It "Returns status from API" {
        # Mock the HTTP call
        Mock Invoke-RestMethod {
            return @{ status = "running" }
        }

        $result = Get-ServerStatus -Server "server01"

        $result | Should -Be "running"
        Should -Invoke Invoke-RestMethod -Times 1 -Exactly
    }
}
```

### Script Analyzer

**Lint PowerShell code for best practices:**

```powershell
# Install PSScriptAnalyzer
Install-Module -Name PSScriptAnalyzer -Scope CurrentUser

# Analyze a script
Invoke-ScriptAnalyzer -Path ./MyScript.ps1

# Analyze with specific rules
Invoke-ScriptAnalyzer -Path ./MyScript.ps1 -Severity Warning, Error

# Exclude specific rules
Invoke-ScriptAnalyzer -Path ./MyScript.ps1 -ExcludeRule PSAvoidUsingWriteHost
```

**Common rules:**

- `PSAvoidUsingWriteHost`: Use `Write-Output` instead
- `PSAvoidUsingInvokeExpression`: Security risk
- `PSUseDeclaredVarsMoreThanAssignments`: Unused variables
- `PSAvoidUsingPlainTextForPassword`: Use `SecureString`

## Security and Compliance

### Credential Management

**Never store credentials in plain text:**

```powershell
# Bad: Plain text password
$password = "MyPassword123"
$username = "admin"

# Good: Use SecureString
$securePassword = Read-Host "Enter password" -AsSecureString
$credential = [PSCredential]::new("admin", $securePassword)

# Good: Use Get-Credential
$credential = Get-Credential -UserName "admin"

# Good: Retrieve from secret store
Install-Module Microsoft.PowerShell.SecretManagement
$password = Get-Secret -Name "AdminPassword"
```

### Just Enough Administration (JEA)

**What it is:** Limits what users can do with elevated privileges.

**When to use:** Scripts that require admin rights but should be restricted.

**Example session configuration:**

```powershell
# JEA configuration file: AdminTools.pssc
@{
    SessionType = 'RestrictedRemoteServer'
    RunAsVirtualAccount = $true
    RoleDefinitions = @{
        'DOMAIN\HelpDesk' = @{
            RoleCapabilities = 'RestartService', 'ViewLogs'
        }
    }
}

# Role capability file: RestartService.psrc
@{
    VisibleCmdlets = @(
        @{ Name = 'Restart-Service'; Parameters = @{ Name = 'Name'; ValidateSet = 'Spooler', 'W3SVC' }}
    )
}
```

### Input Validation

**Validate and sanitize all input:**

```powershell
function Invoke-SqlQuery {
    param(
        [ValidatePattern('^[a-zA-Z0-9_]+$')]
        [string]$TableName,

        [ValidateRange(1, 1000)]
        [int]$MaxRows = 100
    )

    # Additional validation
    if ($TableName -match '(drop|delete|truncate|exec)') {
        throw "Invalid table name: SQL keywords not allowed"
    }

    # Use parameterized queries
    $query = "SELECT TOP $MaxRows * FROM [$TableName]"
    # Execute with proper parameterization...
}
```

### Avoid Command Injection

**Never build commands from user input:**

```powershell
# Bad: Command injection vulnerability
$fileName = Read-Host "Enter file name"
Invoke-Expression "Get-Content $fileName"  # DANGEROUS!

# Good: Use direct cmdlet calls
$fileName = Read-Host "Enter file name"
if (Test-Path $fileName) {
    Get-Content -Path $fileName
}

# Good: Validate input first
function Test-SafeFileName {
    param([string]$FileName)
    return $FileName -match '^[a-zA-Z0-9_.-]+$'
}

if (Test-SafeFileName $fileName) {
    Get-Content -Path $fileName
}
```

### Code Signing

**Sign production scripts:**

```powershell
# Get code signing certificate
$cert = Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert

# Sign script
Set-AuthenticodeSignature -FilePath ./MyScript.ps1 -Certificate $cert

# Verify signature
Get-AuthenticodeSignature -FilePath ./MyScript.ps1
```

## Documentation and Discoverability

### Comment-Based Help

**Every function should have help documentation:**

```powershell
function Get-UserAccount {
    <#
    .SYNOPSIS
        Retrieves user account information from Active Directory.

    .DESCRIPTION
        The Get-UserAccount function queries Active Directory for user account
        details including name, email, department, and account status. It supports
        filtering by various criteria and can retrieve multiple users at once.

    .PARAMETER UserName
        The username (samAccountName) of the user to retrieve. Supports wildcards.

    .PARAMETER Department
        Filter users by department name.

    .PARAMETER IncludeDisabled
        Include disabled user accounts in the results.

    .EXAMPLE
        Get-UserAccount -UserName "jsmith"

        Retrieves the user account for jsmith.

    .EXAMPLE
        Get-UserAccount -UserName "j*" -Department "IT"

        Retrieves all users whose name starts with 'j' in the IT department.

    .EXAMPLE
        Get-UserAccount -Department "Sales" -IncludeDisabled

        Retrieves all users in Sales department, including disabled accounts.

    .INPUTS
        System.String
        You can pipe usernames to this function.

    .OUTPUTS
        PSCustomObject
        Returns custom objects with user account properties.

    .NOTES
        Author: IT Department
        Version: 1.2.0
        Requires: ActiveDirectory module

    .LINK
        https://docs.example.com/Get-UserAccount

    .LINK
        Set-UserAccount
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [string]$UserName,

        [string]$Department,

        [switch]$IncludeDisabled
    )

    # Function implementation...
}
```

**View help:**

```powershell
Get-Help Get-UserAccount
Get-Help Get-UserAccount -Examples
Get-Help Get-UserAccount -Full
Get-Help Get-UserAccount -Online
```

### Module Documentation

**Create about_* help topics:**

```powershell
# File: about_UserManagement.help.txt

TOPIC
    about_UserManagement

SHORT DESCRIPTION
    Provides functions for managing user accounts in Active Directory.

LONG DESCRIPTION
    The UserManagement module contains functions for:
    - Creating and modifying user accounts
    - Managing group memberships
    - Resetting passwords
    - Generating reports

EXAMPLES
    Example 1: Create a new user

        $params = @{
            UserName = "jsmith"
            FirstName = "John"
            LastName = "Smith"
            Department = "IT"
        }
        New-UserAccount @params

    Example 2: Reset user password

        Reset-UserPassword -UserName "jsmith" -SendEmail

KEYWORDS
    User, Account, ActiveDirectory, Management

SEE ALSO
    Get-UserAccount
    Set-UserAccount
    New-UserAccount
```

### Inline Comments

**Comment complex logic:**

```powershell
function Get-LargeFiles {
    param(
        [string]$Path,
        [int]$MinimumSizeMB = 100
    )

    # Convert MB to bytes for comparison
    $minSizeBytes = $MinimumSizeMB * 1MB

    # Get all files recursively, excluding system directories
    # This can take several minutes for large directory structures
    $files = Get-ChildItem -Path $Path -File -Recurse -ErrorAction SilentlyContinue |
        Where-Object { $_.Length -gt $minSizeBytes }

    # Sort by size descending and format output
    # Using calculated properties for human-readable sizes
    $files | Sort-Object Length -Descending | Select-Object @(
        'FullName',
        @{Name='SizeMB'; Expression={[math]::Round($_.Length / 1MB, 2)}},
        'LastWriteTime'
    )
}
```

## Maintenance

- Revisit this document whenever language versions, linters, or project requirements change.
- Record updates with dates and a short rationale in the version history section below.

## Version History

### 1.1.0 (2025-11-07)

- Added comprehensive Pipeline Support section with begin/process/end blocks
- Added Output and Return Values section covering Write-Host vs Write-Output
- Added Performance Best Practices section (array building, string concatenation, parallel processing)
- Added scope and variable management guidance
- Added comparison operators reference
- Added indentation and brace placement standards
- Enhanced with real-world examples for pipeline patterns and performance optimization

### 1.0.0 (2025-11-07)

- Initial publication (extracted from unified coding standards)
- Added researched best practices for security, documentation, tooling, and CI coverage
- Enhanced with detailed explanations, examples, and definitions for beginner programmers

<!-- End of document -->
